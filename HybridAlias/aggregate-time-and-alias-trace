#!/usr/bin/python3
# This file is distributed under the Modified BSD Open Source License.
# See LICENSE.TXT for details.

## Reads the alias trace generated by an instrumented program run line by line
# and accumulates the alias and noalias counts for each loop and pair of variables.

import sys
import yaml
import argparse

def main():
	DEFAULT_SPEEDUP_THRESHOLD = 5

	parser = argparse.ArgumentParser(description='aggregate alias and time profiling data')
	parser.add_argument(
		'alias_data',
		metavar='ALIAS_YAML',
		type=str,
		help='YAML file with alias information')
	parser.add_argument(
		'original_time_trace',
		metavar='TIME_TRACE',
		type=str,
		help='Execution time trace of original program')
	parser.add_argument(
		'speculative_time_trace',
		metavar='CLONING_TIME_TRACE',
		type=str,
		help='Execution time trace of program with cloning')
	parser.add_argument(
		'dst',
		metavar='DST_FILE',
		type=str,
		help='Output file')
	parser.add_argument(
		'--speedup-threshold',
		dest='speedup_threshold',
		type=int,
		default=DEFAULT_SPEEDUP_THRESHOLD,
		help="Percentage, only loops with a speedup higher than this are cloned")

	args = parser.parse_args()

	def clamp(val, lo, hi):
		return max(min(val, hi), lo)

	## how many percent faster should the speculative loop be to be considered lucrative?
	SPEEDUP_THRESHOLD = clamp(float(args.speedup_threshold) / 100, 0, 1)

	file_alias_data             = open(args.alias_data,             "r")
	file_original_time_trace    = open(args.original_time_trace,    "r")
	file_speculative_time_trace = open(args.speculative_time_trace, "r")
	file_dst                    = open(args.dst,                    "w")

	alias_yaml            = load_all_yaml(file_alias_data)
	original_time_yaml    = load_yaml(file_original_time_trace)
	speculative_time_yaml = load_yaml(file_speculative_time_trace)

	# normalize data (LLVMs YAML parser can't handle it normalized)
	alias_data            = group_by_loop(alias_yaml)
	original_time_data    = group_by_loop(original_time_yaml)
	speculative_time_data = group_by_loop(speculative_time_yaml)

	for region in original_time_data:
		original    = original_time_data[region]
		speculative = speculative_time_data[region]

		original_time    = safe_div(original['cycle_count'],    original['sample_count'])
		speculative_time = safe_div(speculative['cycle_count'], speculative['sample_count'])

		speedup = safe_div(original_time, speculative_time) - 1

		print("LOOP %s SPEEDUP OF %.2f%% (%.2f vs %.2f) (want at least %s%%)" % (region, speedup * 100, original_time, speculative_time, SPEEDUP_THRESHOLD * 100))

		if speedup < SPEEDUP_THRESHOLD:
			alias_data.pop(region)

	# denormalize data (LLVMs YAML parser can't handle it normalized)
	alias_data = list(alias_data.values())

	yaml.dump_all(alias_data, file_dst)

def load_all_yaml(file):
	data = yaml.load_all(file)
	data = list(data)

	return yaml_check(data)

def load_yaml(file):
	data = yaml.load(file)

	return yaml_check(data)

def yaml_check(data):
	if data is None:
		data = []

	assert(type(data) is list)

	return data

def safe_div(cycle_count, sample_count):
	if sample_count == 0:
		# we only use this to compute the speedup
		# if both values are one, we get a speedup of 0
		return 1
	return cycle_count / sample_count

def group_by_loop(data):
	map = {}

	for entry in data:
		map[(entry["function"], entry["loop"])] = entry

	return map

main()
