#!/usr/bin/python3
# This file is distributed under the Modified BSD Open Source License.
# See LICENSE.TXT for details.

## Reads the alias trace generated by an instrumented program run line by line
# and accumulates the alias and noalias counts for each loop and pair of variables.

import collections
import re
import sys
import argparse

DEFAULT_SHOULD_NOT_ALIAS_TRESHOLD   =   5
DEFAULT_SHOULD_ALIAS_EXACT_TRESHOLD = 100

parser = argparse.ArgumentParser(description='aggregate alias profiling data')
parser.add_argument(
	'trace_file',
	metavar='TRACE_FILE',
	type=str,
	help='Trace file with alias information')
parser.add_argument(
	'dst_file',
	metavar='DST_FILE',
	type=str,
	help='Output file')
parser.add_argument(
	'--should-not-alias-threshold',
	dest='should_not_alias_threshold',
	type=int,
	default=DEFAULT_SHOULD_NOT_ALIAS_TRESHOLD,
	help="A probability in percent, only pairs with a lower `malloc' alias probability are considered for cloning")
parser.add_argument(
	'--should-alias-exact-threshold',
	dest='should_alias_exact_threshold',
	type=int,
	default=DEFAULT_SHOULD_ALIAS_EXACT_TRESHOLD,
	help='A probability in percent, only pairs with a higher exact aliasing probability are considered for cloning')

args = parser.parse_args()

alias_trace_file = open(args.trace_file, "r")
dst_file         = open(args.dst_file,   "w")

def clamp(val, lo, hi):
	return max(min(val, hi), lo)

# proability threshold from which a pair of pointers is considered 'should-alias'
SHOULD_NOT_ALIAS_TRESHOLD   = clamp(float(args.should_not_alias_threshold)   / 100, 0, 1)
SHOULD_ALIAS_EXACT_TRESHOLD = clamp(float(args.should_alias_exact_threshold) / 100, 0, 1)

ALIAS       = "ALIAS"
NOALIAS     = "NOALIAS"
EXACT_ALIAS = "EXACT_ALIAS"

class TraceReader:
	## iterator that parses the trace file
	# each call to next() returns one alias pair data

	LINE_REGEX = re.compile("^LOOP '([\w.-]+)::([\w.-]+)' - '([\w.-]+)' vs '([\w.-]+)' - ([\w.-]+)$")

	def __init__(self, file):
		self.file = file
		self.line = 0

	def __iter__(self):
		return self

	def __next__(self):
		self.line += 1
		line = self.file.readline()

		if line:
			match = TraceReader.LINE_REGEX.match(line)

			if not match:
				raise Exception('Malformed entry on line ' + str(self.line))

			groups = match.groups()

			if not groups or len(groups) != 5:
				raise Exception('Malformed entry on line ' + str(self.line))

			fn, loop, ptr1, ptr2, alias = match.groups()

			if alias == ALIAS:
				alias = ALIAS
			elif alias == EXACT_ALIAS:
				alias = EXACT_ALIAS
			elif alias == NOALIAS:
				alias = NOALIAS
			else:
				raise Exception('Malformed entry on line ' + str(self.line))

			return (fn, loop, ptr1, ptr2, alias)
		else:
			raise StopIteration


class Counter:
	def __init__(self, ptrs):
		self.ptrs        = ptrs
		self.alias       = 0
		self.exact_alias = 0
		self.noalias     = 0

	@property
	def total(self):
		return self.alias + self.noalias + self.exact_alias

alias_pair = collections.namedtuple('AliasPair', 'ptr1 ptr2')

## parse & aggregate data

data = {}

for fn_name, loop_name, ptr1, ptr2, alias in TraceReader(alias_trace_file):
	loop = data.setdefault((fn_name, loop_name), {})
	pair = alias_pair(*sorted((ptr1, ptr2)))

	if pair not in loop:
		loop[pair] = Counter(pair)

	counter = loop[pair]

	if alias is ALIAS:
		counter.alias += 1
	elif alias is EXACT_ALIAS:
		counter.exact_alias += 1
	elif alias is NOALIAS:
		counter.noalias += 1
	else:
		assert(False)

## analyse numbers & decide should/should-not alias

analyzed_data = {}

for name, pairs in data.items():
	analyzed_pairs = {}

	for pair, counter in pairs.items():
		alias_probability       = (counter.alias + counter.exact_alias) / counter.total
		exact_alias_probability = counter.exact_alias / counter.total

		if exact_alias_probability >= SHOULD_ALIAS_EXACT_TRESHOLD:
			analyzed_pairs[pair] = "should-alias-exact"
		elif alias_probability <= SHOULD_NOT_ALIAS_TRESHOLD:
			analyzed_pairs[pair] = "should-not-alias"
		else:
			analyzed_pairs[pair] = "should-alias"

	analyzed_data[name] = analyzed_pairs

## print out yaml

def _print(*args):
	print(sep="", *args, file=dst_file)

for name, pairs in analyzed_data.items():
	_print('---')
	_print('function: "', name[0], '"')
	_print('loop:     "', name[1], '"')
	_print('alias_pairs:')

	for pair, alias_type in pairs.items():
		_print(2*' ', '- ptr1:  ',    pair.ptr1)
		_print(2*' ', '  ptr2:  ',    pair.ptr2)
		_print(2*' ', '  alias: ',   alias_type)
	_print('...')
